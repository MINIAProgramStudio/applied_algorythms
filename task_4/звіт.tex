\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\title{Прикладні алгоритми. Завдання 2, звіт}
\author{Михайло Голуб}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\begin{document}
\maketitle
\newpage

\textbf{Реалізація UnionFind:}\\\indent

Для зберігання інформації про належність елементу до множини створено клас Node з значеннями value, next та header.\\\indent
Для зберігання інформації про множину створено клас UnionFindSetMeta з значеннями head, tail, root та size, а також методами recalc\_size та recalc\_tail.\\\indent
Для реалізації структури UnionFind створено клас UnionFindHandler з наступною логікою роботи:
\begin{itemize}
\item існує словник універсуму, в якому знаходяться пари елемент-Node, елемент виступає ключем словника; 
\item метод make\_set додає нову пару з вказаним елементом, при цьому в класі Node міститься вказівник на відповідний UnionFindSetMeta;
\item метод find повертає корінь множини якій належить шуканий елемент, або -1 якщо його немає серед ключів словника;
\item метод union об'єднує дві множини до яких належать вказані елементи;
\item метод everything\_in\_one\_set повертає True якщо всі елементи містяться в одній множині, інакше -- False.
\end{itemize}


\textbf{Реалізація алгоритму Крускала:}\\\indent

З другого завдання імпортовано класи графів та класів що генерують випадкові графи. Алгоритм Крускала реалізовано наступним чином:
\begin{enumerate}
\item Алгоритм приймає на вхід зважений неорієнтований граф та видаляє з нього усі петлі;
\item Створюється масив усіх ребер: масив трійок значень (вага, вершина\_1, вершина\_2). При цьому кожна пара вершин опрацьовується лише один раз;
\item Масив усіх ребер сортується від найменшої ваги до найбільшої
\item Створюється зважений неорієнтований граф minimal\_tree з кількістю вершин рівною вхідному графу, але без ребер;
\item Створюється пуста структура UnionFind
\item Обрати неопрацьоване ребро з найменшою вагою;
\item Якщо обидві вершини відсутні в UnionFind -- додати їх туди та об'єднати їх в одну множину; запам'ятати ребро яке їх з'єднує;
\item Якщо одна з множин відсутня в UnionFind -- додати її туди та об'єднати з множиною якій належить інша вершина; запам'ятати ребро яке їх з'єднує;
\item Повторювати 6-8 доки не опрацьовані усі ребра, або "кількість вершин в універсумі рівна кількості вершин в графі та усі елементи UnionFind належать одній множині";
\item Записати в minimal\_tree усі запам'ятовані ребра та повернути його.
\end{enumerate}

\textbf{Аналіз часу роботи алгоритму Крускала:}\\\indent

В найгіршому випадку алгоритм Крускала має складність O(E*logV), де E це кількість ребер і V це кількість вершин. При подвоєнні вірогідності створення ребра очікуване подвоєння часу роботи. При збільшенні кількості вершин очікується спадання швидкості росту часу роботи. На тепловій карті нижче зображено залежність часу роботи алгоритму Крускала від кількості вершин у графі та ймовірності створення ребра.

\begin{center}
    \includegraphics[width=125mm]{map}
\end{center}

З теплової карти видно, що колонки 10 та 20, 20 та 40, 30 та 60, 40 та 80 50 та 100 відрізняються приблизно в два рази, тож лінійну залежність від кількості ребер підтверджено.\\\indent

Для оцінки залежності часу роботи від кількості вершин потрібно створити генератор випадкових графів з фіксованою кількістю ребер при змінній кількості вершин. Створено клас PreciseRandomWeightedGraph який робить саме це. Нижче наведено графік залежності часу роботи алгоритму від кількості вершин при фіксованій кількості ребер $\frac{500*499}{2} = 124750$.


\end{document}